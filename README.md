# Module 9 - High Level Networking

> #### Nanda Nathaniela Meizari - 2206824136

## Reflection

1. ***What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?***
    - `RPC Unary`:
        - Dalam unary RPC, klien mengirimkan satu permintaan ke server dan menunggu satu respons.
        - Komunikasi ini bersifat satu-ke-satu dan sederhana.
        - Cocok digunakan ketika klien perlu mengirimkan data kecil ke server dan mengharapkan respons yang singkat.
        - Contohnya termasuk panggilan RPC untuk autentikasi, pengambilan metadata, atau menjalankan fungsi dengan beberapa parameter yang diharapkan memberikan hasil segera.
    - `Streaming Server RPC`:
        - Dalam metode ini, klien mengirimkan satu permintaan ke server dan menerima aliran respons.
        - Server mengirimkan beberapa respons ke klien, mungkin dalam periode waktu yang lama.
        - Metode ini sesuai ketika server perlu mengirimkan banyak data ke klien atau ketika server melakukan perhitungan yang menghasilkan serangkaian hasil.
        - Contoh penggunaan termasuk pengiriman pembaruan real-time, pengambilan dataset besar yang perlu diproses dalam potongan, atau menerima aliran peristiwa yang berkelanjutan.
    - `Bi-Directional Streaming RPC`:
        - Dalam streaming bi-directional RPC, baik klien maupun server dapat mengirim dan menerima aliran pesan satu sama lain.
        - Kedua belah pihak dapat mengirim dan menerima pesan secara independen.
        - Ini cocok untuk aplikasi yang membutuhkan komunikasi dua arah nyata antara klien dan server.
        - Contohnya termasuk aplikasi kolaborasi real-time, permainan, atau situasi lainnya di mana interaksi waktu nyata dan pertukaran data yang luas diperlukan.

2. ***What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?***
    - `Authentication`:
        - Gunakan mekanisme autentikasi yang kuat seperti TLS (Transport Layer Security) untuk mengotentikasi komunikasi antara klien dan server.
        - Terapkan TLS mutual (mTLS) di mana baik klien maupun server saling mengotentikasi menggunakan sertifikat, memastikan kedua belah pihak adalah siapa yang mereka klaim.
        - Implementasikan protokol autentikasi seperti OAuth 2.0 atau JWT (JSON Web Tokens) untuk autentikasi pengguna, terutama dalam skenario di mana klien perlu mengotentikasi dengan server.
    - `Authorization`:
        - Terapkan mekanisme kontrol akses untuk membatasi akses terhadap sumber daya berdasarkan identitas klien.
        - Implementasikan role-based access control (RBAC) atau attribute-based access control (ABAC) untuk mendefinisikan dan menegakkan kebijakan otorisasi.
        - Pastikan keputusan otorisasi dibuat secara konsisten di semua titik akhir layanan dan ditegakkan di sisi server untuk mencegah akses yang tidak sah.
    -  `Data Encryption`:
        - Data Encryption sensitif baik dalam transit maupun saat istirahat untuk melindunginya dari akses yang tidak sah.
        - Gunakan TLS untuk mengenkripsi data dalam transit, memastikan semua komunikasi antara klien dan server terenkripsi.
        - Terapkan algoritma enkripsi yang kuat dan praktik manajemen kunci untuk melindungi data yang disimpan di disk atau dalam penyimpanan.
        - Pertimbangkan untuk mengenkripsi data di tingkat aplikasi sebelum menyimpannya dalam basis data, terutama untuk informasi yang sangat sensitif.

3. ***What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?***
Mengelola streaming bi-directional di Rust gRPC, terutama dalam skenario seperti aplikasi chat, menghadirkan tantangan dalam concurrency, penanganan kesalahan, manajemen koneksi, dan kontrol aliran. Pengelolaan komunikasi asinkron antara klien dan server memerlukan sinkronisasi dan penanganan kesalahan yang hati-hati untuk memastikan konsistensi dan keandalan data. Selain itu, masalah seperti back pressure, pengurutan pesan, skalabilitas, dan pengujian menambah kompleksitas yang harus diatasi untuk menjaga kinerja dan stabilitas. Solusi efektif melibatkan pemanfaatan kemampuan pemrograman asinkron Rust, implementasi mekanisme penanganan kesalahan yang kuat, optimalisasi manajemen koneksi, dan menerapkan strategi kontrol aliran untuk mengelola aliran pesan secara efektif. Pengujian dan debugging menyeluruh sangat penting untuk mengidentifikasi dan mengatasi masalah potensial, memastikan stabilitas dan kinerja dari aplikasi Rust gRPC dengan streaming bi-directional.

4. ***What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?***
    - `Advantages`:
        - `Integrasi Seamless dengan Tokio`: `ReceiverStream` menyediakan integrasi yang mulus dengan runtime asinkron `Tokio`, yang sangat cocok untuk aplikasi yang sudah menggunakan `Tokio`untuk I/O asinkron.
        - `Fleksibilitas dalam Mengelola Stream`: Memberikan fleksibilitas dalam mengelola berbagai jenis aliran data, memungkinkan layanan Rust gRPC untuk menangani respons streaming secara efisien tanpa memblokir event loop.
    - `Disadvantages`:
        - `Ketergantungan pada Tokio`: Pendekatan ini menciptakan ketergantungan pada `Tokio`, yang mungkin tidak selaras dengan proyek yang menggunakan runtime asinkron lainnya.
        - `Fitur Terbatas untuk Skenario Streaming Lanjutan`: Meskipun `ReceiverStream` cocok untuk skenario streaming dasar, ia mungkin kekurangan beberapa fitur lanjutan dan opsi kustomisasi yang ditemukan di perpustakaan streaming lain.
        - `Kurva Pembelajaran`: Pengembang yang baru dengan pemrograman asinkron di Rust atau `Tokio` mungkin menghadapi kurva pembelajaran saat bekerja dengan `ReceiverStream`, terutama jika mereka tidak terbiasa dengan API dan konsep `Tokio`.

5. ***In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?***
Untuk meningkatkan penggunaan ulang kode, modularitas, maintainability, dan ekstensibilitas dalam layanan Rust gRPC, struktur kode sebaiknya dibangun dengan pemisahan kepentingan yang jelas, di mana definisi layanan terpisah dari implementasinya. Hal ini memudahkan pergantian implementasi. Penerapan pola injeksi ketergantungan dan penggunaan trait memungkinkan kopling yang longgar antar komponen yang mempromosikan kemudahan pengujian dan fleksibilitas. Komponen dan utilitas yang dapat digunakan kembali harus dienkapsulasi ke dalam modul atau crate mandiri, memungkinkan penggunaan ulang lintas berbagai bagian kode secara mudah.

6. ***In the `MyPaymentService` implementation, what additional steps might be necessary to handle more complex payment processing logic?***
Untuk mengelola logika pemrosesan pembayaran yang lebih kompleks dalam implementasi MyPaymentService, beberapa langkah tambahan diperlukan. Ini termasuk validasi menyeluruh dan penanganan kesalahan untuk memastikan integritas data dan respons yang tepat terhadap kesalahan. Selain itu, implementasi konkurensi dan pemrosesan paralel untuk optimasi kinerja, kepatuhan terhadap standar keamanan dan persyaratan kepatuhan, serta pembentukan mekanisme pemantauan dan peringatan untuk kesehatan sistem juga perlu dijadikan prioritas.

7. ***What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?***
Penggunaan gRPC sebagai protokol komunikasi secara signifikan memengaruhi arsitektur dan desain sistem terdistribusi, terutama dalam hal interoperabilitas dengan teknologi dan platform lainnya. Dengan menggunakan HTTP/2 sebagai protokol transportasinya, gRPC mencapai efisiensi dan kinerja yang lebih baik melalui fitur-fitur seperti multiplexing dan kompresi header. Dengan Protocol Buffers (Protobuf) sebagai format serialisasi default untuk mendefinisikan kontrak layanan, gRPC memastikan komunikasi agnostik bahasa, memungkinkan layanan yang ditulis dalam bahasa pemrograman yang berbeda untuk berinteraksi dengan lancar. Pembangkitan kode dari definisi Protobuf memfasilitasi tipe kuat dan validasi waktu kompilasi, meningkatkan kemudahan pemeliharaan kode di berbagai platform. Kemampuan streaming dua arah dan komunikasi asinkron memungkinkan pertukaran data real-time, mendukung arsitektur reaktif dan meningkatkan pengalaman pengguna. Integrasi dengan mekanisme penemuan layanan, penyeimbangan beban, dan keamanan memastikan skalabilitas, toleransi kesalahan, dan komunikasi yang aman dalam sistem terdistribusi. Meskipun berfokus pada arsitektur mikro layanan modern, gRPC menyediakan kompatibilitas dengan sistem yang ada melalui fitur-fitur seperti transkoding JSON dan dukungan HTTP/1.x, memfasilitasi migrasi bertahap dan interoperabilitas dengan infrastruktur warisan. Secara keseluruhan, adopsi gRPC memungkinkan pengembangan sistem terdistribusi yang efisien, skalabel, dan interoperabel yang sesuai dengan tuntutan aplikasi kontemporer.

8. ***What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?***
Menggunakan HTTP/2 sebagai protokol dasar untuk gRPC menawarkan beberapa keuntungan dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket untuk REST API, termasuk multiplexing, kompresi header, server push, dan prioritas aliran, yang secara kolektif menghasilkan penurunan latensi, peningkatan efisiensi, dan pemanfaatan sumber daya jaringan yang lebih baik. Namun, HTTP/2 memperkenalkan kompleksitas yang lebih tinggi dalam implementasi dan debugging, mungkin menghadapi masalah kompatibilitas dengan sistem-sistem lama, dan berpotensi mengkonsumsi lebih banyak sumber daya server dibandingkan dengan HTTP/1.1. Selain itu, meskipun HTTP/2 mendukung komunikasi dua arah, WebSocket lebih cocok untuk skenario komunikasi real-time dan full-duplex. Pilihan antara HTTP/2, HTTP/1.1, atau WebSocket tergantung pada faktor-faktor seperti persyaratan kinerja, kendala kompatibilitas, dan kasus penggunaan API tertentu, dengan para pengembang perlu mempertimbangkan secara hati-hati kompromi sebelum membuat keputusan.

9. ***How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?***
Model request-response dari REST API berbeda dengan kemampuan streaming dua arah dari gRPC dalam beberapa aspek kunci, terutama berkaitan dengan komunikasi real-time dan responsivitas. Dalam REST API, klien biasanya memulai permintaan ke server, yang kemudian memproses permintaan tersebut dan mengembalikan respons. Model ini cocok untuk skenario di mana interaksi terutama diinisiasi oleh klien dan tidak memiliki status (stateless), seperti pengambilan data atau operasi CRUD (Create, Read, Update, Delete). Namun, REST API mungkin menghadapi batasan dalam skenario komunikasi real-time di mana klien memerlukan pembaruan kontinu atau perlu menerima acara atau notifikasi secara asinkron. Sebaliknya, gRPC mendukung streaming dua arah, memungkinkan klien dan server untuk mengirimkan beberapa pesan secara asinkron melalui satu koneksi. Ini memungkinkan komunikasi real-time dan responsivitas dengan memfasilitasi pertukaran data yang kontinu dan memungkinkan server untuk mendorong pembaruan ke klien segera setelah tersedia. Selain itu, kemampuan streaming dua arah dari gRPC sangat menguntungkan untuk skenario seperti aplikasi obrolan, streaming langsung, atau pengeditan kolaboratif, di mana beberapa pihak perlu berkomunikasi secara real-time dan menerima pembaruan secara instan. Secara keseluruhan, sementara REST API unggul dalam interaksi permintaan-respon tradisional, kemampuan streaming dua arah dari gRPC menawarkan kinerja dan responsivitas yang lebih baik untuk skenario komunikasi real-time.

10. ***What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?***
Pendekatan berbasis skema dari gRPC, menggunakan Protocol Buffers, berbeda dengan sifat yang lebih fleksibel dan tanpa skema dari JSON dalam muatan REST API, menyebabkan beberapa implikasi. Protocol Buffers menerapkan tipe yang ketat, memastikan pertukaran data yang terdefinisi dengan baik dan tipe yang kuat antara layanan-layanan gRPC, yang divalidasi pada waktu kompilasi, sementara JSON dalam REST API menawarkan fleksibilitas yang lebih besar, memungkinkan struktur muatan yang dinamis tanpa ketaatan skema yang ketat. Fleksibilitas ini dapat memfasilitasi berbagai format data dan kebutuhan yang berkembang namun dapat memperkenalkan inkonsistensi dan tantangan validasi. Selain itu, Protocol Buffers memungkinkan serialisasi dan transmisi yang efisien, menghasilkan ukuran muatan yang lebih kecil dan kinerja yang lebih tinggi dibandingkan dengan JSON dalam REST API. Pembangkitan kode otomatis berdasarkan definisi pesan Protobuf memastikan kontrak API yang konsisten dan perpustakaan klien yang idiomatik di berbagai platform, meningkatkan interoperabilitas, sementara versi dan evolusi dikelola lebih lancar dalam gRPC. Namun, REST API berbasis JSON mendapatkan manfaat dari ekosistem yang lebih luas dari alat dan perpustakaan dan mungkin lebih disukai untuk skenario di mana fleksibilitas dan familiaritas menjadi prioritas utama. Pada akhirnya, pilihan antara gRPC dan REST API tergantung pada faktor-faktor seperti kinerja, kebutuhan interoperabilitas, dan preferensi pengembangan.
